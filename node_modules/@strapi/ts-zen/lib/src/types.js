"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Factories
exports.default = {
    array: (type) => ({
        kind: 1 /* TypeKind.Array */,
        type,
        toString() {
            return type ? `Array<${type.toString()}>` : 'Array';
        },
    }),
    bigInt: () => ({
        kind: 2 /* TypeKind.BigInt */,
        toString() {
            return 'bigint';
        },
    }),
    bigIntLiteral: (value) => ({
        kind: 3 /* TypeKind.BigIntLiteral */,
        value,
        toString() {
            return value ? String(value) : 'BigIntLiteral';
        },
    }),
    boolean: () => ({
        kind: 4 /* TypeKind.Boolean */,
        toString() {
            return 'boolean';
        },
    }),
    booleanLiteral: (value) => ({
        kind: 5 /* TypeKind.BooleanLiteral */,
        value,
        toString() {
            return value ? String(value) : 'BooleanLiteral';
        },
    }),
    intersection: (types) => ({
        kind: 8 /* TypeKind.Intersection */,
        types,
        toString() {
            return types ? types.map((type) => type.toString()).join(' & ') : 'intersection';
        },
    }),
    mappedType: (options) => ({
        kind: 14 /* TypeKind.Object */,
        objectKind: 32 /* ObjectKind.Mapped */,
        ...options,
        toString() {
            if (!options?.properties || !options?.templateType) {
                return 'MappedType';
            }
            const index = `[x in ${options.properties.join(' | ')}]`;
            const templateType = options.templateType?.toString();
            return `{ ${index}: ${templateType}; }`;
        },
    }),
    never: () => ({
        kind: 10 /* TypeKind.Never */,
        toString() {
            return 'never';
        },
    }),
    null: () => ({
        kind: 11 /* TypeKind.Null */,
        toString() {
            return 'null';
        },
    }),
    number: () => ({
        kind: 12 /* TypeKind.Number */,
        toString() {
            return 'number';
        },
    }),
    numberLiteral: (value) => ({
        kind: 13 /* TypeKind.NumberLiteral */,
        value,
        toString() {
            return value ? String(value) : 'NumberLiteral';
        },
    }),
    anonymousObject: (options) => ({
        kind: 14 /* TypeKind.Object */,
        objectKind: 16 /* ObjectKind.Anonymous */,
        indexes: options?.indexes,
        properties: options?.properties,
        toString() {
            const indexesAsString = Object.entries(options?.indexes ?? [])
                .map(([key, { keyType, type }]) => `[${key}: ${keyType.toString()}]: ${type.toString()};`)
                .join(' ');
            const propertiesAsString = Object.entries(options?.properties ?? [])
                .map(([key, type]) => `"${key}": ${type};`)
                .join(' ');
            const objectMembersAsString = [propertiesAsString, indexesAsString]
                .filter((s) => s) // only keep non-empty strings
                .join(' ');
            return objectMembersAsString ? `{ ${objectMembersAsString} }` : 'object';
        },
    }),
    object: (object) => {
        const defaultObject = {
            kind: 14 /* TypeKind.Object */,
            objectKind: 16 /* ObjectKind.Anonymous */,
            toString() {
                return 'object';
            },
        };
        return object ?? defaultObject;
    },
    string: () => ({
        kind: 15 /* TypeKind.String */,
        toString() {
            return 'string';
        },
    }),
    stringLiteral: (value) => ({
        kind: 16 /* TypeKind.StringLiteral */,
        value,
        toString() {
            return value ? `"${value}"` : 'StringLiteral';
        },
    }),
    symbol: (unique = false) => ({
        kind: 17 /* TypeKind.Symbol */,
        unique,
        toString() {
            return unique ? 'UniqueESSymbol' : 'ESSymbol';
        },
    }),
    templateLiteral: (template) => ({
        kind: 18 /* TypeKind.TemplateLiteral */,
        template,
        toString() {
            const templateAsString = template?.reduce((str, item) => (typeof item === 'string' ? str + item : str + `\${${item.toString()}}`), '');
            return templateAsString ? `"${templateAsString}"` : 'TemplateLiteral';
        },
    }),
    tuple: (types) => ({
        kind: 19 /* TypeKind.Tuple */,
        types,
        toString() {
            return `[${(types ?? []).map((type) => type.toString()).join(', ')}]`;
        },
    }),
    undefined: () => ({
        kind: 20 /* TypeKind.Undefined */,
        toString() {
            return 'undefined';
        },
    }),
    union: (types) => ({
        kind: 21 /* TypeKind.Union */,
        types,
        toString() {
            return types ? types.map((type) => type.toString()).join(' | ') : 'union';
        },
    }),
    unknown: () => ({
        kind: 22 /* TypeKind.Unknown */,
        toString() {
            return 'unknown';
        },
    }),
    void: () => ({
        kind: 23 /* TypeKind.Void */,
        toString() {
            return 'void';
        },
    }),
};
//# sourceMappingURL=types.js.map