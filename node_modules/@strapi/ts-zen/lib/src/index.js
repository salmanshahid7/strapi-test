"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromRaw = exports.fromRecord = exports.fromFile = exports.t = void 0;
const load_1 = require("./load");
const errors_1 = require("./errors");
function fromFile(path, options) {
    return (0, load_1.loadFromFile)(path, options);
}
exports.fromFile = fromFile;
function fromRecord(record, options) {
    return (0, load_1.loadFromRecord)(record, options);
}
exports.fromRecord = fromRecord;
function fromRaw(code, options) {
    return (0, load_1.loadFromRaw)(code, options);
}
exports.fromRaw = fromRaw;
__exportStar(require("./types"), exports);
var types_1 = require("./types");
Object.defineProperty(exports, "t", { enumerable: true, get: function () { return __importDefault(types_1).default; } });
expect.extend({
    toAssertTypeWith(typeName, matcherName, params, matchers, matcherUtils) {
        if (!(matcherName in matchers)) {
            throw new Error(`Unknown matcher ${String(matcherName)} for type "${typeName}"`);
        }
        const matcher = matchers[matcherName];
        let result;
        try {
            result = matcher.call(matchers, matcherUtils.getContext(), ...params);
        }
        catch (e) {
            // Transform expectation errors to regular expect results
            if (e instanceof errors_1.ExpectationError) {
                result = { pass: false, message: e.getMessage };
            }
            // Re-throw regular errors
            else
                throw e;
        }
        const { pass, message } = result;
        // Extract the isNot state variable after calling the matcher to make sure it won't be modified again
        const { isNot } = matcherUtils.getState();
        return { pass: isNot ? !pass : pass, message };
    },
});
//# sourceMappingURL=index.js.map