"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSourceFromRaw = exports.createSourceFromRecord = exports.createSourceFromFile = void 0;
const typescript_1 = __importDefault(require("typescript"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const source_1 = require("../source");
const ALLOWED_FILE_EXT = ['.ts', '.d.ts'];
function createSourceFromFile(filePath, options = {}) {
    const stats = fs_1.default.statSync(filePath);
    if (!stats.isFile()) {
        throw new Error(`File not found at "${path_1.default}"`);
    }
    const extName = path_1.default.extname(filePath);
    if (!ALLOWED_FILE_EXT.includes(extName)) {
        throw new Error(`Invalid file extension. Found "${extName}" but expected one of the following: ${ALLOWED_FILE_EXT.join(', ')}`);
    }
    const fileContent = fs_1.default.readFileSync(filePath).toString();
    /**
     * Make sure the source file baseUrl is set to the file base directory (if not overridden)
     */
    if (typeof options.baseUrl === 'undefined') {
        options.baseUrl = path_1.default.dirname(path_1.default.resolve(filePath));
    }
    return {
        kind: source_1.SourceKind.File,
        getOptions() {
            return options;
        },
        toString() {
            return fileContent;
        },
    };
}
exports.createSourceFromFile = createSourceFromFile;
function createSourceFromRecord(record, options) {
    const code = Object.entries(record)
        // Transform each type declaration into an inline type definition
        // TODO: Instead of generating raw strings, we could parse the declarations into ts nodes and emit + format them
        .map(([typeName, typeDeclaration]) => {
        const { params, definition } = typeDeclaration;
        const hasParams = params !== undefined && params.length > 0;
        return hasParams
            ? `type ${typeName}<${params.join(', ')}> = ${definition};`
            : `type ${typeName} = ${definition};`;
    })
        .join(typescript_1.default.sys.newLine);
    return {
        kind: source_1.SourceKind.Record,
        getOptions() {
            return options;
        },
        toString() {
            return code;
        },
    };
}
exports.createSourceFromRecord = createSourceFromRecord;
function createSourceFromRaw(code, options) {
    return {
        kind: source_1.SourceKind.Raw,
        getOptions() {
            return options;
        },
        toString() {
            return code;
        },
    };
}
exports.createSourceFromRaw = createSourceFromRaw;
// re-export source types
__exportStar(require("./types"), exports);
//# sourceMappingURL=index.js.map