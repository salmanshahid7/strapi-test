"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.matcherUtils = exports.createWrappedMatchers = exports.createMatchers = void 0;
const matchersUtils = __importStar(require("./utils"));
const matchers_1 = require("./matchers");
const createMatchers = (typeName, options) => {
    const matcherState = { isNot: false };
    const getState = () => {
        return matcherState;
    };
    const setState = (state) => {
        Object.assign(matcherState, state);
    };
    const symbol = options.symbols[typeName];
    const type = symbol ? options.checker.getDeclaredTypeOfSymbol(symbol) : undefined;
    const statement = matchersUtils.getStatementFromSymbol(options.sourceFile, symbol);
    const matcherContext = {
        ...options,
        originalTypeName: typeName,
        path: typeName,
        symbol,
        type,
        statement,
        getState,
        setState,
        get isNot() {
            return getState().isNot;
        },
    };
    const matchers = (0, matchers_1.getMatchers)();
    return {
        matchers: {
            ...matchers,
            get not() {
                setState({ isNot: true });
                return matchers;
            },
        },
        matchersUtils: {
            getState,
            setState,
            getContext() {
                return matcherContext;
            },
        },
    };
};
exports.createMatchers = createMatchers;
const createWrappedMatchers = (typeName, options) => {
    const { matchers, matchersUtils } = (0, exports.createMatchers)(typeName, options);
    const matcherKeys = Object.keys(matchers);
    const wrappedMatchers = matcherKeys.reduce((acc, matcherKey) => ({
        ...acc,
        [matcherKey]: (...params) => {
            expect(typeName).toAssertTypeWith(matcherKey, params, matchers, matchersUtils);
        },
    }), {});
    return {
        matchers: {
            ...wrappedMatchers,
            get not() {
                matchersUtils.setState({ isNot: true });
                return wrappedMatchers;
            },
        },
        matchersUtils,
    };
};
exports.createWrappedMatchers = createWrappedMatchers;
exports.matcherUtils = __importStar(require("./utils"));
//# sourceMappingURL=index.js.map