"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ok = exports.getStatementFromSymbol = exports.printUnexpectedType = exports.expectType = exports.expectLiteral = exports.ensureTemplateLiteral = exports.ensureTypeReference = exports.ensureObject = exports.ensureDefined = exports.stringifyTsType = exports.stringifyObjectFlags = exports.stringifyTypeFlags = exports.extractAllObjectFlags = exports.extractAllTypeFlags = exports.contextFrom = exports.safeExpect = exports.isTupleType = exports.isArrayType = exports.isOfType = exports.arrayDiff = void 0;
const typescript_1 = __importDefault(require("typescript"));
const jestUtils = __importStar(require("jest-matcher-utils"));
const errors_1 = require("../errors");
const arrayDiff = (a, b) => a.filter((item) => !b.includes(item));
exports.arrayDiff = arrayDiff;
const isOfType = (type, flags) => {
    return type.flags === flags;
};
exports.isOfType = isOfType;
function isArrayType(type, checker) {
    return checker.isArrayType(type);
}
exports.isArrayType = isArrayType;
function isTupleType(type, checker) {
    return checker.isTupleType(type);
}
exports.isTupleType = isTupleType;
const safeExpect = (callback) => {
    try {
        return callback();
    }
    catch (e) {
        if (e instanceof errors_1.ExpectationError) {
            return { pass: false, message: e.getMessage };
        }
        // re-throw other errors
        else
            throw e;
    }
};
exports.safeExpect = safeExpect;
const contextFrom = (initialContext, context) => ({ ...initialContext, ...context });
exports.contextFrom = contextFrom;
const extractAllTypeFlags = (flags) => {
    if (!flags) {
        return [];
    }
    return (Object.values(typescript_1.default.TypeFlags)
        // Half of enum items are keys and half are values, so we need to filter by index
        .filter((flag) => typeof flag === 'number' && flag === (flag & flags)));
};
exports.extractAllTypeFlags = extractAllTypeFlags;
const extractAllObjectFlags = (flags) => {
    if (!flags) {
        return [];
    }
    return (Object.values(typescript_1.default.ObjectFlags)
        // Half of enum items are keys and half are values, so we need to filter by index
        .filter((flag) => typeof flag === 'number' && flag === (flag & flags)));
};
exports.extractAllObjectFlags = extractAllObjectFlags;
const stringifyTypeFlags = (flags) => {
    const allFlags = (0, exports.extractAllTypeFlags)(flags).sort((a, b) => (a < b ? 1 : -1));
    const toString = (flag) => typescript_1.default.TypeFlags[flag];
    const [baseFlag, ...params] = allFlags.map(toString);
    if (params.length === 0) {
        return baseFlag;
    }
    return `${baseFlag}<${params.join(',')}>`;
};
exports.stringifyTypeFlags = stringifyTypeFlags;
const stringifyObjectFlags = (flags) => {
    const toString = (flag) => typescript_1.default.ObjectFlags[flag];
    const allFlags = (0, exports.extractAllObjectFlags)(flags)
        .sort((a, b) => (a < b ? 1 : -1))
        .map(toString);
    if (allFlags.length === 0) {
        return '';
    }
    return allFlags.join(', ');
};
exports.stringifyObjectFlags = stringifyObjectFlags;
const stringifyTsType = (type, context) => {
    return type
        ? context.checker.typeToString(type, context.sourceFile.endOfFileToken, typescript_1.default.TypeFormatFlags.InTypeAlias)
        : 'undefined';
};
exports.stringifyTsType = stringifyTsType;
function ensureDefined(expected, matcherName, context) {
    if (expected === undefined || expected === null) {
        const message = () => jestUtils.matcherErrorMessage(jestUtils.matcherHint(matcherName, context.path, '', { isNot: context.isNot }), 'this matcher expects a valid type name', jestUtils.printWithType('Expected', expected, jestUtils.printExpected));
        throw new errors_1.ExpectationError(message);
    }
}
exports.ensureDefined = ensureDefined;
function ensureObject(expected, matcherName, context) {
    if (!(0, exports.isOfType)(expected, typescript_1.default.TypeFlags.Object)) {
        const message = () => jestUtils.matcherErrorMessage(jestUtils.matcherHint(matcherName, context.path, '', { isNot: context.isNot }), 'this matcher expects a valid object type', jestUtils.printWithType('Expected', expected, jestUtils.printExpected));
        throw new errors_1.ExpectationError(message);
    }
}
exports.ensureObject = ensureObject;
function ensureTypeReference(type, matcherName, context) {
    const isTypeReference = (0, exports.isOfType)(type, typescript_1.default.TypeFlags.Object) &&
        (0, exports.extractAllObjectFlags)(type.objectFlags).includes(typescript_1.default.ObjectFlags.Reference);
    if (!isTypeReference) {
        const message = () => jestUtils.matcherErrorMessage(jestUtils.matcherHint(matcherName, context.path, '', { isNot: context.isNot }), 'this matcher expects a type reference', `Received: ${jestUtils.printReceived(context.checker.typeToString(type, context.sourceFile.endOfFileToken, typescript_1.default.TypeFormatFlags.InTypeAlias))}`);
        throw new errors_1.ExpectationError(message);
    }
}
exports.ensureTypeReference = ensureTypeReference;
function ensureTemplateLiteral(type, matcherName, context) {
    const isTemplateLiteral = (0, exports.isOfType)(type, typescript_1.default.TypeFlags.TemplateLiteral);
    if (!isTemplateLiteral) {
        const message = () => jestUtils.matcherErrorMessage(jestUtils.matcherHint(matcherName, context.path, '', { isNot: context.isNot }), 'this matcher expects a template literal', `Received: ${jestUtils.printReceived(context.checker.typeToString(type, context.sourceFile.endOfFileToken, typescript_1.default.TypeFormatFlags.InTypeAlias))}`);
        throw new errors_1.ExpectationError(message);
    }
}
exports.ensureTemplateLiteral = ensureTemplateLiteral;
const expectLiteral = (type, flags, expected, matcherName, context) => {
    const hasCorrectFlags = (0, exports.isOfType)(type, flags);
    if (!hasCorrectFlags) {
        return {
            pass: false,
            message: () => jestUtils.matcherHint(matcherName, context.path, '', { isNot: context.isNot }) +
                '\n\n' +
                jestUtils.printDiffOrStringify((0, exports.stringifyTypeFlags)(type.flags), (0, exports.stringifyTypeFlags)(flags), 'Expected', 'Received', false),
        };
    }
    return {
        pass: expected === undefined ? true : expected === type.value,
        message: () => jestUtils.matcherHint(matcherName, context.path, String(expected), { isNot: context.isNot }) +
            '\n\n' +
            jestUtils.printDiffOrStringify(expected, type.value, 'Expected', 'Received', true),
    };
};
exports.expectLiteral = expectLiteral;
const expectType = (type, flags, matcherName, context) => {
    const pass = (0, exports.isOfType)(type, flags);
    const stringifiedFlags = (0, exports.stringifyTypeFlags)(flags);
    const message = () => {
        return (0, exports.printUnexpectedType)(stringifiedFlags, pass ? stringifiedFlags : (0, exports.stringifyTsType)(context.type, context), matcherName, context);
    };
    return { pass, message };
};
exports.expectType = expectType;
const printUnexpectedType = (expected, received, matcherName, context) => {
    return (jestUtils.matcherHint(matcherName, context.path, '', {
        isNot: context.isNot,
    }) +
        '\n\n' +
        jestUtils.printDiffOrStringify(expected, received, 'Expected', 'Received', false));
};
exports.printUnexpectedType = printUnexpectedType;
const getStatementFromSymbol = (sourceFile, symbol) => {
    if (symbol === undefined) {
        return undefined;
    }
    return sourceFile.statements.find((statement) => {
        // For some reason Symbol & Type don't expose "id" in their definitions, but it's there in this context.
        // Also, statements might not have symbols attached to them
        const statementSymbolId = statement.symbol?.id;
        const actualSymbolId = symbol.id;
        return statementSymbolId === actualSymbolId;
    });
};
exports.getStatementFromSymbol = getStatementFromSymbol;
const ok = (message) => ({
    pass: true,
    message: message ?? (() => ''),
});
exports.ok = ok;
//# sourceMappingURL=utils.js.map