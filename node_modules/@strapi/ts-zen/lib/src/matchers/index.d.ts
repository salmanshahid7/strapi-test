import type { CreateMatchersOptions, CreateMatchersResult, Matchers } from './types';
export declare const createMatchers: (typeName: string, options: CreateMatchersOptions) => CreateMatchersResult;
export declare const createWrappedMatchers: (typeName: string, options: CreateMatchersOptions) => {
    matchers: {
        not: Matchers<void | Promise<void>>;
        equals(expected: string): void | Promise<void>;
        hasArguments(expected: Record<string, import("..").Type>): void | Promise<void>;
        hasNbArguments(expected: number): void | Promise<void>;
        is(expected: import("..").Type): void | Promise<void>;
        isAnonymousObject(expected?: Pick<import("..").AnonymousObjectType, "properties" | "indexes"> | undefined): void | Promise<void>;
        isAny(): void | Promise<void>;
        isArray(expected?: import("..").Type | undefined): void | Promise<void>;
        isBigInt(): void | Promise<void>;
        isBigIntLiteral(expected?: bigint | undefined): void | Promise<void>;
        isBoolean(): void | Promise<void>;
        isBooleanLiteral(expected?: boolean | undefined): void | Promise<void>;
        isDefined(): void | Promise<void>;
        isIntersection(expected?: import("..").Type[] | undefined): void | Promise<void>;
        isMappedType(expected?: Pick<import("..").MappedObjectType, "properties" | "templateType"> | undefined): void | Promise<void>;
        isNever(): void | Promise<void>;
        isNotDefined(): void | Promise<void>;
        isNull(): void | Promise<void>;
        isNumber(): void | Promise<void>;
        isNumberLiteral(expected?: number | undefined): void | Promise<void>;
        isObject(expected?: import("..").ObjectType | undefined): void | Promise<void>;
        isString(): void | Promise<void>;
        isStringLiteral(expected?: string | undefined): void | Promise<void>;
        isSymbol(expected?: {
            unique?: boolean | undefined;
        } | undefined): void | Promise<void>;
        isTemplateLiteral(expected?: (string | import("..").Type)[] | undefined): void | Promise<void>;
        isTuple(expected?: import("..").Type[] | undefined): void | Promise<void>;
        isTypeReference(typeName?: string | undefined, args?: Record<string, import("..").Type> | undefined): void | Promise<void>;
        isUndefined(): void | Promise<void>;
        isUnion(expected?: import("..").Type[] | undefined): void | Promise<void>;
        isUnknown(): void | Promise<void>;
        isVoid(): void | Promise<void>;
    };
    matchersUtils: import("./types").MatchersUtils;
};
export * as matcherUtils from './utils';
export type * from './types';
//# sourceMappingURL=index.d.ts.map