import type { ExpectResult, MatcherContext } from '../matchers';
import ts from 'typescript';
export declare const arrayDiff: (a: string[], b: string[]) => string[];
export declare const isOfType: <T extends ts.Type = ts.Type>(type: ts.Type, flags: ts.TypeFlags) => type is T;
export declare function isArrayType(type: ts.Type, checker: ts.TypeChecker): type is ts.TypeReference;
export declare function isTupleType(type: ts.Type, checker: ts.TypeChecker): type is ts.TupleType;
export declare const safeExpect: (callback: () => ExpectResult) => ExpectResult;
export declare const contextFrom: (initialContext: MatcherContext, context: Partial<MatcherContext>) => MatcherContext;
export declare const extractAllTypeFlags: <T extends ts.TypeFlags>(flags?: T | undefined) => T[];
export declare const extractAllObjectFlags: <T extends ts.ObjectFlags>(flags?: T | undefined) => T[];
export declare const stringifyTypeFlags: <T extends ts.TypeFlags>(flags?: T | undefined) => string;
export declare const stringifyObjectFlags: <T extends ts.ObjectFlags>(flags?: T | undefined) => string;
export declare const stringifyTsType: <T extends ts.Type>(type: T | undefined, context: MatcherContext) => string;
export declare function ensureDefined<T>(expected: T, matcherName: string, context: MatcherContext): asserts expected is NonNullable<T>;
export declare function ensureObject(expected: ts.Type, matcherName: string, context: MatcherContext): asserts expected is ts.ObjectType;
export declare function ensureTypeReference(type: ts.Type, matcherName: string, context: MatcherContext): asserts type is ts.TypeReference;
export declare function ensureTemplateLiteral(type: ts.Type, matcherName: string, context: MatcherContext): asserts type is ts.TemplateLiteralType;
export declare const expectLiteral: <T extends ts.Type>(type: T, flags: ts.TypeFlags, expected: ts.LiteralType['value'] | undefined, matcherName: string, context: MatcherContext) => ExpectResult;
export declare const expectType: <T extends ts.Type>(type: T, flags: ts.TypeFlags, matcherName: string, context: MatcherContext) => {
    pass: boolean;
    message: () => string;
};
export declare const printUnexpectedType: (expected: string, received: string, matcherName: string, context: MatcherContext) => string;
export declare const getStatementFromSymbol: (sourceFile: ts.SourceFile, symbol?: ts.Symbol) => ts.Statement | undefined;
export declare const ok: (message?: () => string) => ExpectResult;
//# sourceMappingURL=utils.d.ts.map